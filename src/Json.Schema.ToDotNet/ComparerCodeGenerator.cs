// Copyright (c) Microsoft Corporation.  All Rights Reserved.
// Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Json.Schema.ToDotNet
{
    /// <summary>
    /// Generates classes that implement <see cref="System.Collections.Generic.IComparer{T}"/>.
    /// </summary>
    internal class ComparerCodeGenerator
    {
        internal const string InstancePropertyName = "Instance";

        private const string UriClassName = nameof(Uri);
        private const string GenericTypeName = "T";
        private const string ObjectTypeName = "object";
        private const string CountPropertyName = "Count";
        private const string GenericKeyTypeName = "TKey";
        private const string GenericValueTypeName = "TValue";
        private const string LeftEqualsArgumentName = "left";
        private const string RightEqualsArgumentName = "right";
        private const string CompareDelegateName = "compareFunction";
        private const string CompareResultVariableName = "compareResult";
        private const string UriOrignalStringPropertyName = "OriginalString";
        private const string ComparerExtensionsClassName = "ComparerExtensions";

        private const string ComparerSuffix = "Comparer";
        private const string IListInterfaceName = nameof(IList);
        private const string IComparerInterfaceName = nameof(IComparer);
        private const string IComparableInterfaceName = nameof(IComparable);
        private const string IDictionaryInterfaceName = nameof(IDictionary);

        // method names
        private const string UriCompares = nameof(UriCompares);
        private const string ListCompares = nameof(ListCompares);
        private const string ObjectCompares = nameof(ObjectCompares);
        private const string ListComparesHelper = nameof(ListComparesHelper);
        private const string DictionaryCompares = nameof(DictionaryCompares);
        private const string TryReferenceCompares = nameof(TryReferenceCompares);
        private const string DictionaryComparesHelper = nameof(DictionaryComparesHelper);

        private readonly string _namespaceName;
        private readonly string _copyrightNotice;

        private string _className;
        private TypeSyntax _classType;
        private PropertyInfoDictionary _propertyInfoDictionary;
        private readonly LocalVariableNameGenerator _localVariableNameGenerator;

        /// <summary>
        /// Initializes a new instance of the <see cref="ComparerCodeGenerator"/> class.
        /// </summary>
        /// <param name="copyrightNotice">
        /// The copyright notice to display at the top of the file, or null if there is
        /// no copyright notice.
        /// </param>
        /// <param name="namespaceName">
        /// The name of the namespace into which the classes generated by this object
        /// are to be placed.
        /// </param>
        internal ComparerCodeGenerator(string copyrightNotice, string namespaceName)
        {
            _namespaceName = namespaceName;
            _copyrightNotice = copyrightNotice;
            _localVariableNameGenerator = new LocalVariableNameGenerator();
        }

        /// <summary>
        /// Gets a string containing the name of the comparer class generated by
        /// the most recent class to <see cref="Generate(string, PropertyInfoDictionary)"/>.
        /// </summary>
        internal static string GetComparerClassName(string className)
        {
            return className + ComparerSuffix;
        }

        /// <summary>
        /// Generates a class that implements <see cref="System.Collections.Generic.IComparer{T}"/>
        /// for the specified class.
        /// </summary>
        /// <param name="className">
        /// The name of the class whose comparer class is to be generated.
        /// </param>
        /// <param name="propertyInfoDictionary">
        /// An object containing information about each property in the class specified by <paramref name="className"/>.
        /// </param>
        /// <returns>
        /// A string containing the text of the generated comparer class.
        /// </returns>
        internal string Generate(string className, PropertyInfoDictionary propertyInfoDictionary)
        {
            _className = className;
            _propertyInfoDictionary = propertyInfoDictionary;
            _classType = SyntaxFactory.ParseTypeName(_className);
            _localVariableNameGenerator.Reset();

            string comparerClassName = GetComparerClassName(_className);
            var comparerInterface = GetBaseType(_className, IComparerInterfaceName);

            ClassDeclarationSyntax classDeclaration =
                SyntaxFactory.ClassDeclaration(comparerClassName)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                        SyntaxFactory.Token(SyntaxKind.SealedKeyword))
                    .AddBaseListTypes(comparerInterface)
                    .AddMembers(
                        GenerateInstanceProperty(),
                        GenerateCompareMethod());

            var usings = new HashSet<string>
            {
                "System",                       // For Object.
                "System.Collections.Generic"    // For IComparer<T>
            };

            IEnumerable<string> namespaceNames = _propertyInfoDictionary
                .Values
                .Select(propertyInfo => propertyInfo.NamespaceName)
                .Where(namespaceName => !string.IsNullOrWhiteSpace(namespaceName));

            foreach (string namespaceName in namespaceNames)
            {
                usings.Add(namespaceName);
            }

            return classDeclaration.Format(
                _copyrightNotice,
                usings,
                _namespaceName,
                MakeSummaryComment());
        }

        internal static BaseTypeSyntax GetBaseType(string className, string baseTypeName)
        {
            return SyntaxFactory.SimpleBaseType(
                SyntaxFactory.GenericName(
                    SyntaxFactory.Identifier(baseTypeName),
                    SyntaxFactory.TypeArgumentList(SyntaxFactory.SeparatedList(
                        new TypeSyntax[] {
                            SyntaxFactory.ParseTypeName(className)}))));
        }

        internal static BaseTypeSyntax GetComparerBaseType(string className)
        {
            return GetBaseType(className, IComparerInterfaceName);
        }

        private string MakeSummaryComment()
        {
            return string.Format(
                CultureInfo.CurrentCulture,
                Resources.ComparerSummary,
                _className);
        }

        private MemberDeclarationSyntax GenerateInstanceProperty()
        {
            TypeSyntax comparerType = SyntaxFactory.ParseTypeName(GetComparerClassName(_className));

            /*
            public static readonly ComparerType Instance = new ComparerType();
            */
            return SyntaxFactory.FieldDeclaration(
                default(SyntaxList<AttributeListSyntax>),
                SyntaxFactory.TokenList(
                    SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword),
                    SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword)),
                SyntaxFactory.VariableDeclaration(comparerType,
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.VariableDeclarator(
                            SyntaxFactory.Identifier(InstancePropertyName),
                            default(BracketedArgumentListSyntax),
                            SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.ObjectCreationExpression(
                                    comparerType,
                                    SyntaxHelper.ArgumentList(),
                                    default(InitializerExpressionSyntax)))))));
        }

        private IList<StatementSyntax> GeneratePropertyComparisons()
        {
            var statements = new List<StatementSyntax>();

            foreach (string propertyName in _propertyInfoDictionary.GetPropertyNames())
            {
                statements.AddRange(
                    GeneratePropertyComparison(
                        propertyName,
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(LeftEqualsArgumentName),
                            SyntaxFactory.IdentifierName(propertyName)),
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                            SyntaxFactory.IdentifierName(propertyName))));
            }

            statements.Add(
                SyntaxFactory.ReturnStatement(
                    SyntaxFactory.IdentifierName(CompareResultVariableName)));

            return statements;
        }

        private IList<StatementSyntax> GeneratePropertyComparison(
            string propertyName,
            ExpressionSyntax left,
            ExpressionSyntax right)
        {
            ComparisonKind comparisonKind = _propertyInfoDictionary[propertyName].ComparisonKind;
            string propertyType = _propertyInfoDictionary[propertyName].TypeName;
            switch (comparisonKind)
            {
                case ComparisonKind.OperatorEquals:
                    return GenerateComparisonWithCompareTo(left, right, propertyType);

                case ComparisonKind.ObjectEquals:
                    return GenerateComparisonWithObjectCompares(left, right);

                case ComparisonKind.EqualityComparerEquals:
                    return GenerateComparisonWithComparerInstance(propertyName, left, right);

                case ComparisonKind.Collection:
                    return GenerateCollectionComaprison(propertyName, left, right);

                case ComparisonKind.Dictionary:
                    return GenerateDictionaryComparison(propertyName, left, right);

                default:
                    throw new ArgumentException($"Property {propertyName} has unknown comparison kind {comparisonKind}.");
            }
        }

        private IList<StatementSyntax> GenerateComparisonWithCompareTo(
            ExpressionSyntax left,
            ExpressionSyntax right,
            string propertyType)
        {
            var statements = new List<StatementSyntax>();

            InvocationExpressionSyntax invocation;
            if (propertyType.Equals("string", StringComparison.OrdinalIgnoreCase))
            {
                invocation = GenerateStringCompareInvocation(left, right);
            }
            else if (propertyType.Equals("uri", StringComparison.OrdinalIgnoreCase))
            {
                invocation = GenerateUriComparesInvocation(left, right);
            }
            else
            {
                /*
                left.Property.CompareTo(right.Property);
                */
                invocation =
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            left,
                            SyntaxFactory.IdentifierName(WellKnownMethodNames.CompareTo)),
                        SyntaxHelper.ArgumentList(right));
            }

            statements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                        invocation)));

            statements.Add(CheckCompareResultAndReturn());

            return statements;
        }

        private IList<StatementSyntax> GenerateComparisonWithObjectCompares(
            ExpressionSyntax left,
            ExpressionSyntax right)
        {
            var statements = new List<StatementSyntax>();
            statements.Add(
                /*
                compareResult = left.ObjectCompares(right);
                */
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                left,
                                SyntaxFactory.IdentifierName(ObjectCompares)),
                            SyntaxHelper.ArgumentList(right)))));

            statements.Add(CheckCompareResultAndReturn());

            return statements;
        }

        private IList<StatementSyntax> GenerateComparisonWithComparerInstance(
            string propertyName,
            ExpressionSyntax left,
            ExpressionSyntax right)
        {
            string typeName = _propertyInfoDictionary[propertyName].TypeName + ComparerSuffix;

            var statements = new List<StatementSyntax>();
            statements.Add(
                /*
                compareResult = PropertyComparer.InstancePropertyName.Compare(left.Property, right.Property);
                */
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    SyntaxFactory.ParseTypeName(typeName),
                                    SyntaxFactory.IdentifierName(InstancePropertyName)),
                                SyntaxFactory.IdentifierName(WellKnownMethodNames.Compare)),
                            SyntaxHelper.ArgumentList(left, right)))));

            statements.Add(CheckCompareResultAndReturn());

            return statements;
        }

        private StatementSyntax[] GenerateCollectionComaprison(
            string propertyInfoKey,
            ExpressionSyntax left,
            ExpressionSyntax right)
        {
            var argumentList = new List<ExpressionSyntax>() { right };
            string elmentTypeKey = PropertyInfoDictionary.MakeElementKeyName(propertyInfoKey);
            ExpressionSyntax additionalArgument = GenerateAdditionalCompareArgument(elmentTypeKey);

            if (additionalArgument != null)
            {
                argumentList.Add(additionalArgument);
            }

            var statements = new List<StatementSyntax>();

            /*
            compareResult = left.ListProperty.ListCompares(right.ListProperty, PropertyComparer.Instance);
            */
            statements.Add(SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName(CompareResultVariableName),
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            left,
                            SyntaxFactory.IdentifierName(ListCompares)),
                        SyntaxHelper.ArgumentList(argumentList.ToArray())))));

            statements.Add(CheckCompareResultAndReturn());

            return statements.ToArray();
        }

        private ExpressionSyntax GenerateAdditionalCompareArgument(string propertyInfoKey)
        {
            const string delegateFirstParamName = "a";
            const string delegateSecondParamName = "b";

            ComparisonKind comparisonKind = _propertyInfoDictionary[propertyInfoKey].ComparisonKind;
            string propertyTypeName = _propertyInfoDictionary[propertyInfoKey].TypeName;
            string comparerTypeName = propertyTypeName + ComparerSuffix;

            switch (comparisonKind)
            {
                case ComparisonKind.OperatorEquals:
                    return propertyTypeName.Equals("uri", StringComparison.OrdinalIgnoreCase)
                        ? CompareInvocationLambdaExpression(
                            UriCompares,
                            delegateFirstParamName,
                            delegateSecondParamName)
                        : null;

                case ComparisonKind.ObjectEquals:
                    return CompareInvocationLambdaExpression(
                        ObjectCompares,
                        delegateFirstParamName,
                        delegateSecondParamName);

                case ComparisonKind.EqualityComparerEquals:
                    return SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.ParseTypeName(comparerTypeName),
                        SyntaxFactory.IdentifierName(InstancePropertyName));

                case ComparisonKind.Collection:
                    return CompareInvocationLambdaExpression(
                        ListCompares,
                        delegateFirstParamName,
                        delegateSecondParamName);

                case ComparisonKind.Dictionary:
                    return CompareInvocationLambdaExpression(
                        DictionaryCompares,
                        delegateFirstParamName,
                        delegateSecondParamName);

                default:
                    throw new ArgumentException($"Property {propertyInfoKey} has unsupported comparison kind {comparisonKind}.");
            }
        }

        private StatementSyntax[] GenerateDictionaryComparison(
            string propertyInfoKey,
            ExpressionSyntax left,
            ExpressionSyntax right)
        {
            string elmentTypeKey = PropertyInfoDictionary.MakeDictionaryItemKeyName(propertyInfoKey);
            ComparisonKind comparisonKind = _propertyInfoDictionary[elmentTypeKey].ComparisonKind;
            string comparerTypeName = _propertyInfoDictionary[elmentTypeKey].TypeName + ComparerSuffix;

            var argumentList = new List<ExpressionSyntax>() { right };

            if (comparisonKind == ComparisonKind.EqualityComparerEquals)
            {
                argumentList.Add(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.ParseTypeName(comparerTypeName),
                        SyntaxFactory.IdentifierName(InstancePropertyName)));
            }

            var statements = new List<StatementSyntax>();

            /*
            compareResult = left.DictProperty.DictionaryCompares(right.DictProperty, PropertyComparer.Instance);
            */
            statements.Add(SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName(CompareResultVariableName),
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            left,
                            SyntaxFactory.IdentifierName(DictionaryCompares)),
                        SyntaxHelper.ArgumentList(argumentList.ToArray())))));

            statements.Add(CheckCompareResultAndReturn());

            return statements.ToArray();
        }

        private MemberDeclarationSyntax GenerateCompareMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                WellKnownMethodNames.Compare)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                        .WithType(_classType),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                        .WithType(_classType))
                .AddBodyStatements(
                    GenerateCompareBody());
        }

        private StatementSyntax[] GenerateCompareBody()
        {
            var statements = new List<StatementSyntax>();

            statements.Add(DeclareCompareResultLocalVariable(CompareResultVariableName));
            statements.Add(CallTryReferenceComparesMethod());
            statements.AddRange(GeneratePropertyComparisons());

            return statements.ToArray();
        }

        private InvocationExpressionSyntax GenerateStringCompareInvocation(ExpressionSyntax left, ExpressionSyntax right)
        {
            /*
            string.Compare(left, right)
            */
            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                    SyntaxFactory.IdentifierName(WellKnownMethodNames.Compare)),
                SyntaxHelper.ArgumentList(left, right));
        }

        private InvocationExpressionSyntax GenerateUriComparesInvocation(ExpressionSyntax left, ExpressionSyntax right)
        {
            /*
            left.UriCompares(right)
            */
            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    left,
                    SyntaxFactory.IdentifierName(UriCompares)),
                SyntaxHelper.ArgumentList(right));
        }

        #region Extension Methods Generation

        internal static string GetComparerExtensionsClassName()
        {
            return ComparerExtensionsClassName;
        }

        internal string GenerateExtensionClass()
        {
            this._localVariableNameGenerator.Reset();
            string comparerClassName = GetComparerExtensionsClassName();

            ClassDeclarationSyntax classDeclaration =
                SyntaxFactory.ClassDeclaration(comparerClassName)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                    .AddMembers(
                        GenerateComparerExtensionsMethods());

            var usings = new HashSet<string>
            {
                "System",                       // For Object.
                "System.Collections.Generic",   // For IComparer<T>
                "System.Linq"                   // For ToList()
            };

            return classDeclaration.Format(
                _copyrightNotice,
                usings,
                _namespaceName,
                string.Empty);
        }

        private MemberDeclarationSyntax[] GenerateComparerExtensionsMethods()
        {
            var statements = new List<MemberDeclarationSyntax>();

            statements.AddRange(this.GenerateTryReferenceComparesExtensionMethod());
            statements.AddRange(this.GenerateListComparesExtensionMethods());
            statements.AddRange(this.GenerateDictionaryComparesExtensionMethods());
            statements.AddRange(this.GenerateUriComparesExtensionMethod());
            statements.AddRange(this.GenerateObjectComparesExtensionMethod());

            return statements.ToArray();
        }

        private List<MethodDeclarationSyntax> GenerateTryReferenceComparesExtensionMethod()
        {
            var methods = new List<MethodDeclarationSyntax>();

            /*
            public static bool TryReferenceCompares(this object left, object right, out int compareResult)
            {
                compareResult = 0;

                if (object.ReferenceEquals(left, right))
                {
                    return true;
                }

                if (left == null)
                {
                    result = -1;
                    return true;
                }

                if (right == null)
                {
                    result = 1;
                    return true;
                }

                return false;
            }
            */
            var firstArgument = SyntaxFactory.IdentifierName(LeftEqualsArgumentName);
            var secondArgument = SyntaxFactory.IdentifierName(RightEqualsArgumentName);

            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.BoolKeyword)),
                    TryReferenceCompares)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                    .AddParameterListParameters(
                        SyntaxFactory.Parameter(
                            SyntaxFactory.Identifier(LeftEqualsArgumentName))
                            .WithType(SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.ObjectKeyword)))
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
                        SyntaxFactory.Parameter(
                            SyntaxFactory.Identifier(RightEqualsArgumentName))
                            .WithType(SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.ObjectKeyword))),
                        SyntaxFactory.Parameter(
                            SyntaxFactory.Identifier(CompareResultVariableName))
                            .WithType(SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.IntKeyword)))
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.OutKeyword)))
                    .AddBodyStatements(
                            SyntaxFactory.ExpressionStatement(
                                SyntaxFactory.AssignmentExpression(
                                    SyntaxKind.SimpleAssignmentExpression,
                                    SyntaxFactory.IdentifierName(CompareResultVariableName),
                                    SyntaxFactory.LiteralExpression(
                                        SyntaxKind.NumericLiteralExpression,
                                        SyntaxFactory.Literal(0)))),
                            SyntaxFactory.IfStatement(
                                SyntaxHelper.AreSameObjects(firstArgument, secondArgument),
                                SyntaxFactory.Block(
                                    SyntaxFactory.SingletonList<StatementSyntax>(
                                        SyntaxHelper.Return(true)))),
                            SyntaxFactory.IfStatement(
                                SyntaxHelper.IsNull(firstArgument),
                                SyntaxFactory.Block(
                                    SyntaxFactory.ExpressionStatement(
                                        SyntaxFactory.AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            SyntaxFactory.IdentifierName(CompareResultVariableName),
                                            SyntaxFactory.LiteralExpression(
                                                SyntaxKind.NumericLiteralExpression,
                                                SyntaxFactory.Literal(-1)))),
                                    SyntaxHelper.Return(true))),
                            SyntaxFactory.IfStatement(
                                SyntaxHelper.IsNull(secondArgument),
                                SyntaxFactory.Block(
                                    SyntaxFactory.ExpressionStatement(
                                        SyntaxFactory.AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            SyntaxFactory.IdentifierName(CompareResultVariableName),
                                            SyntaxFactory.LiteralExpression(
                                                SyntaxKind.NumericLiteralExpression,
                                                SyntaxFactory.Literal(1)))),
                                    SyntaxHelper.Return(true))),
                            SyntaxHelper.Return(false)));

            return methods;
        }

        private List<MethodDeclarationSyntax> GenerateListComparesExtensionMethods()
        {
            const string delegateFirstParamName = "a";
            const string delegateSecondParamName = "b";
            const string comparerLocalVarName = "comparer";
            var methods = new List<MethodDeclarationSyntax>();
            var loopIndexerVariable = SyntaxFactory.IdentifierName("i");
            var firstArgument = SyntaxFactory.IdentifierName(LeftEqualsArgumentName);
            var secondArgument = SyntaxFactory.IdentifierName(RightEqualsArgumentName);

            /*
            public static int ListCompares<T>(this IList<T> left, IList<T> right) where T : IComparable
            {
                return CompareListHelper(left, right, (a, b) => a.CompareTo(b));
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(ListCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName)))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))))
                .AddConstraintClauses(
                    SyntaxFactory.TypeParameterConstraintClause(
                        SyntaxFactory.IdentifierName(GenericTypeName))
                    .AddConstraints(
                        SyntaxFactory.TypeConstraint(
                            SyntaxFactory.IdentifierName(IComparableInterfaceName))))
                .AddBodyStatements(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName(ListComparesHelper))
                        .AddArgumentListArguments(
                            SyntaxFactory.Argument(firstArgument),
                            SyntaxFactory.Argument(secondArgument),
                            SyntaxFactory.Argument(
                                CompareInvocationLambdaExpression(
                                    WellKnownMethodNames.CompareTo,
                                    delegateFirstParamName,
                                    delegateSecondParamName))))));

            /*
            public static int ListCompares<T>(this IList<T> left, IList<T> right, IComparer<T> comparer)
            {
                if (comparer == null)
                {
                    throw new ArgumentNullException(nameof(comparer));
                }

                return CompareListHelper(left, right, comparer.Compare);
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(ListCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(comparerLocalVarName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IComparerInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))))
                .WithBody(
                    SyntaxFactory.Block(
                        AugumentNullCheck(comparerLocalVarName),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(ListComparesHelper))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(firstArgument),
                                SyntaxFactory.Argument(secondArgument),
                                SyntaxFactory.Argument(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName(comparerLocalVarName),
                                        SyntaxFactory.IdentifierName(WellKnownMethodNames.Compare))))))));

            /*
            public static int ListCompares<T>(this IList<T> left, IList<T> right, Func<T, T, int> compareFunction)
            {
                return ListComparesHelper(left, right, compareFunction);
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(ListCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName)))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    CompareFunctionParameter(CompareDelegateName, GenericTypeName, GenericTypeName))
                .AddBodyStatements(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName(ListComparesHelper))
                        .AddArgumentListArguments(
                            SyntaxFactory.Argument(firstArgument),
                            SyntaxFactory.Argument(secondArgument),
                            SyntaxFactory.Argument(SyntaxFactory.IdentifierName(CompareDelegateName))))));

            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(ListComparesHelper))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IListInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    CompareFunctionParameter(CompareDelegateName, GenericTypeName, GenericTypeName))
                .WithBody(
                    SyntaxFactory.Block(
                        AugumentNullCheck(CompareDelegateName),
                        DeclareCompareResultLocalVariable(CompareResultVariableName),
                        CallTryReferenceComparesMethod(),
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                SyntaxFactory.IdentifierName(CompareResultVariableName),
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            firstArgument,
                                            SyntaxFactory.IdentifierName(CountPropertyName)),
                                        SyntaxFactory.IdentifierName(WellKnownMethodNames.CompareTo)))
                                .AddArgumentListArguments(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                            SyntaxFactory.IdentifierName(CountPropertyName)))))),
                        CheckCompareResultAndReturn(),
                        SyntaxFactory.ForStatement(
                            SyntaxFactory.Block(
                                SyntaxFactory.IfStatement(
                                    SyntaxFactory.BinaryExpression(
                                        SyntaxKind.LogicalAndExpression,
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.ElementAccessExpression(
                                                    firstArgument,
                                                    SyntaxHelper.BracketedArgumentList(loopIndexerVariable)),
                                                SyntaxFactory.IdentifierName(TryReferenceCompares)))
                                        .AddArgumentListArguments(
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                                    SyntaxHelper.BracketedArgumentList(loopIndexerVariable))),
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.IdentifierName(CompareResultVariableName))
                                            .WithRefOrOutKeyword(
                                                SyntaxFactory.Token(SyntaxKind.OutKeyword))),
                                        SyntaxFactory.BinaryExpression(
                                            SyntaxKind.NotEqualsExpression,
                                            SyntaxFactory.IdentifierName(CompareResultVariableName),
                                            SyntaxFactory.LiteralExpression(
                                                SyntaxKind.NumericLiteralExpression,
                                                SyntaxFactory.Literal(0)))),
                                    SyntaxFactory.Block(
                                        SyntaxFactory.SingletonList<StatementSyntax>(
                                            SyntaxFactory.ReturnStatement(
                                                SyntaxFactory.IdentifierName(CompareResultVariableName))))),
                                SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression,
                                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.IdentifierName(CompareDelegateName))
                                        .AddArgumentListArguments(
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    firstArgument,
                                                    SyntaxHelper.BracketedArgumentList(loopIndexerVariable))),
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                                    SyntaxHelper.BracketedArgumentList(loopIndexerVariable)))))),
                                CheckCompareResultAndReturn()))
                        .WithDeclaration(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.PredefinedType(
                                    SyntaxFactory.Token(SyntaxKind.IntKeyword)))
                            .AddVariables(
                                SyntaxFactory.VariableDeclarator(
                                    SyntaxFactory.Identifier("i"))
                                .WithInitializer(
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.LiteralExpression(
                                            SyntaxKind.NumericLiteralExpression,
                                            SyntaxFactory.Literal(0))))))
                        .WithCondition(
                            SyntaxFactory.BinaryExpression(
                                SyntaxKind.LessThanExpression,
                                loopIndexerVariable,
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    firstArgument,
                                    SyntaxFactory.IdentifierName(CountPropertyName))))
                        .AddIncrementors(
                            SyntaxFactory.PrefixUnaryExpression(
                                SyntaxKind.PreIncrementExpression,
                                loopIndexerVariable)),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.IdentifierName(CompareResultVariableName)))));

            return methods;
        }

        private List<MethodDeclarationSyntax> GenerateDictionaryComparesExtensionMethods()
        {
            const string loopIndexerName = "i";
            const string keyDelegateFirstParamName = "a";
            const string keyDelegateSecondParamName = "b";
            const string valDelegateFirstParamName = "c";
            const string valDelegateSecondParamName = "d";
            const string comparerLocalVarName = "comparer";
            const string firstKeyListVariableName = "leftKeys";
            const string secondKeyListVariableName = "rightKeys";
            const string keyCompareDelegateName = "keyCompareFunction";
            const string valueCompareDelegateName = "valueCompareFunction";

            var firstArgument = SyntaxFactory.IdentifierName(LeftEqualsArgumentName);
            var secondArgument = SyntaxFactory.IdentifierName(RightEqualsArgumentName);
            var methods = new List<MethodDeclarationSyntax>();

            /*
            public static int DictionaryCompares<T>(this IDictionary<string, T> left, IDictionary<string, T> right) where T : IComparable
            {
                return DictionaryCompareHelper(left, right, (a, b) => a.CompareTo(b), (c, d) => c.CompareTo(d));
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(DictionaryCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                            SyntaxFactory.IdentifierName(GenericTypeName)))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                        .WithType(SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                            SyntaxFactory.IdentifierName(GenericTypeName))))
                .AddConstraintClauses(
                    SyntaxFactory.TypeParameterConstraintClause(
                        SyntaxFactory.IdentifierName(GenericTypeName))
                    .AddConstraints(
                        SyntaxFactory.TypeConstraint(
                            SyntaxFactory.IdentifierName(IComparableInterfaceName))))
                .AddBodyStatements(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName(DictionaryComparesHelper))
                        .AddArgumentListArguments(
                            SyntaxFactory.Argument(firstArgument),
                            SyntaxFactory.Argument(secondArgument),
                            SyntaxFactory.Argument(
                                CompareInvocationLambdaExpression(
                                    WellKnownMethodNames.CompareTo,
                                    keyDelegateFirstParamName,
                                    keyDelegateSecondParamName)),
                            SyntaxFactory.Argument(
                                CompareInvocationLambdaExpression(
                                    WellKnownMethodNames.CompareTo,
                                    valDelegateFirstParamName,
                                    valDelegateSecondParamName))))));

            /*
            public static int DictionaryCompares<T>(this IDictionary<string, T> left, IDictionary<string, T> right, IComparer<T> comparer)
            {
                if (comparer == null)
                {
                    throw new ArgumentNullException(nameof(comparer));
                }

                return DictionaryCompareHelper(left, right, (a, b) => a.CompareTo(b), comparer.Compare);
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(DictionaryCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                            SyntaxFactory.IdentifierName(GenericTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(comparerLocalVarName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IComparerInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericTypeName))))
                .WithBody(
                    SyntaxFactory.Block(
                        AugumentNullCheck(comparerLocalVarName),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(DictionaryComparesHelper))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(firstArgument),
                                SyntaxFactory.Argument(secondArgument),
                                SyntaxFactory.Argument(
                                    CompareInvocationLambdaExpression(
                                        WellKnownMethodNames.CompareTo,
                                        keyDelegateFirstParamName,
                                        keyDelegateSecondParamName)),
                                SyntaxFactory.Argument(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName(comparerLocalVarName),
                                        SyntaxFactory.IdentifierName(WellKnownMethodNames.Compare))))))));
            /*
            public static int DictionaryCompares<TKey, TValue>(this IDictionary<TKey, TValue> left, IDictionary<TKey, TValue> right, Func<TKey, TKey, int> keyCompareFunction, Func<TValue, TValue, int> valueCompareFunction)
            {
                return DictionaryCompareHelper(left, right, (a, b) => keyCompareFunction(a, b), (c, d) => valueCompareFunction(c, d));
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(DictionaryCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericKeyTypeName)),
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericValueTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericKeyTypeName),
                            SyntaxFactory.IdentifierName(GenericValueTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericKeyTypeName),
                            SyntaxFactory.IdentifierName(GenericValueTypeName))),
                    CompareFunctionParameter(keyCompareDelegateName, GenericKeyTypeName, GenericKeyTypeName),
                    CompareFunctionParameter(valueCompareDelegateName, GenericValueTypeName, GenericValueTypeName))
                .WithBody(
                    SyntaxFactory.Block(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(DictionaryComparesHelper))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(firstArgument),
                                SyntaxFactory.Argument(secondArgument),
                                SyntaxFactory.Argument(
                                    CompareFunctionLambdaExpression(keyCompareDelegateName, keyDelegateFirstParamName, keyDelegateSecondParamName)),
                                SyntaxFactory.Argument(
                                    CompareFunctionLambdaExpression(valueCompareDelegateName, valDelegateFirstParamName, valDelegateSecondParamName)))))));

            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(DictionaryComparesHelper))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericKeyTypeName)),
                    SyntaxFactory.TypeParameter(
                        SyntaxFactory.Identifier(GenericValueTypeName)))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericKeyTypeName),
                            SyntaxFactory.IdentifierName(GenericValueTypeName))),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.GenericName(
                            SyntaxFactory.Identifier(IDictionaryInterfaceName))
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(GenericKeyTypeName),
                            SyntaxFactory.IdentifierName(GenericValueTypeName))),
                    CompareFunctionParameter(keyCompareDelegateName, GenericKeyTypeName, GenericKeyTypeName),
                    CompareFunctionParameter(valueCompareDelegateName, GenericValueTypeName, GenericValueTypeName))
                .WithBody(
                    SyntaxFactory.Block(
                        AugumentNullCheck(keyCompareDelegateName),
                        AugumentNullCheck(valueCompareDelegateName),
                        DeclareCompareResultLocalVariable(CompareResultVariableName),
                        CallTryReferenceComparesMethod(),
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                SyntaxFactory.IdentifierName(CompareResultVariableName),
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            firstArgument,
                                            SyntaxFactory.IdentifierName(CountPropertyName)),
                                        SyntaxFactory.IdentifierName(WellKnownMethodNames.CompareTo)))
                                .AddArgumentListArguments(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                            SyntaxFactory.IdentifierName(CountPropertyName)))))),
                        CheckCompareResultAndReturn(),
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.GenericName(
                                    SyntaxFactory.Identifier(IListInterfaceName))
                                .AddTypeArgumentListArguments(
                                    SyntaxFactory.IdentifierName(GenericKeyTypeName)))
                            .AddVariables(
                                SyntaxFactory.VariableDeclarator(
                                    SyntaxFactory.Identifier(firstKeyListVariableName))
                                .WithInitializer(
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    firstArgument,
                                                    SyntaxFactory.IdentifierName("Keys")),
                                                SyntaxFactory.IdentifierName(WellKnownMethodNames.ToList))))))),
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.GenericName(
                                    SyntaxFactory.Identifier(IListInterfaceName))
                                .AddTypeArgumentListArguments(
                                    SyntaxFactory.IdentifierName(GenericKeyTypeName)))
                            .AddVariables(
                                SyntaxFactory.VariableDeclarator(
                                    SyntaxFactory.Identifier(secondKeyListVariableName))
                                .WithInitializer(
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                                    SyntaxFactory.IdentifierName("Keys")),
                                                SyntaxFactory.IdentifierName(WellKnownMethodNames.ToList))))))),
                        SyntaxFactory.ForStatement(
                            SyntaxFactory.Block(
                                SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression,
                                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.IdentifierName(keyCompareDelegateName))
                                        .AddArgumentListArguments(
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    SyntaxFactory.IdentifierName(firstKeyListVariableName),
                                                    SyntaxHelper.BracketedArgumentList(
                                                        SyntaxFactory.IdentifierName(loopIndexerName)))),
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    SyntaxFactory.IdentifierName(secondKeyListVariableName),
                                                    SyntaxHelper.BracketedArgumentList(
                                                        SyntaxFactory.IdentifierName(loopIndexerName))))))),
                                CheckCompareResultAndReturn(),
                                SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression,
                                        SyntaxFactory.IdentifierName(CompareResultVariableName),
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.IdentifierName(valueCompareDelegateName))
                                        .AddArgumentListArguments(
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    firstArgument,
                                                    SyntaxHelper.BracketedArgumentList(
                                                        SyntaxFactory.ElementAccessExpression(
                                                            SyntaxFactory.IdentifierName(firstKeyListVariableName),
                                                            SyntaxHelper.BracketedArgumentList(
                                                                SyntaxFactory.IdentifierName(loopIndexerName)))))),
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.ElementAccessExpression(
                                                    SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                                    SyntaxHelper.BracketedArgumentList(
                                                        SyntaxFactory.ElementAccessExpression(
                                                            SyntaxFactory.IdentifierName(secondKeyListVariableName),
                                                            SyntaxHelper.BracketedArgumentList(
                                                                SyntaxFactory.IdentifierName(loopIndexerName))))))))),
                                CheckCompareResultAndReturn()))
                        .WithDeclaration(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.PredefinedType(
                                    SyntaxFactory.Token(SyntaxKind.IntKeyword)))
                            .AddVariables(
                                SyntaxFactory.VariableDeclarator(
                                    SyntaxFactory.Identifier(loopIndexerName))
                                .WithInitializer(
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.LiteralExpression(
                                            SyntaxKind.NumericLiteralExpression,
                                            SyntaxFactory.Literal(0))))))
                        .WithCondition(
                            SyntaxFactory.BinaryExpression(
                                SyntaxKind.LessThanExpression,
                                SyntaxFactory.IdentifierName(loopIndexerName),
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    SyntaxFactory.IdentifierName(firstKeyListVariableName),
                                    SyntaxFactory.IdentifierName(CountPropertyName))))
                        .AddIncrementors(
                            SyntaxFactory.PrefixUnaryExpression(
                                SyntaxKind.PreIncrementExpression,
                                SyntaxFactory.IdentifierName(loopIndexerName))),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.IdentifierName(CompareResultVariableName)))));

            return methods;
        }

        private List<MethodDeclarationSyntax> GenerateUriComparesExtensionMethod()
        {
            var methods = new List<MethodDeclarationSyntax>();
            /*
            public static int UriCompares(this Uri left, Uri right)
            {
                int compareResult = 0;

                if (left.TryReferenceCompares(right, out compareResult))
                {
                    return compareResult;
                }

                return left.OriginalString.CompareTo(right.OriginalString);
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(UriCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    .WithType(
                        SyntaxFactory.IdentifierName(UriClassName)),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.IdentifierName(UriClassName)))
                .WithBody(
                    SyntaxFactory.Block(
                        DeclareCompareResultLocalVariable(CompareResultVariableName),
                        CallTryReferenceComparesMethod(),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName(LeftEqualsArgumentName),
                                        SyntaxFactory.IdentifierName(UriOrignalStringPropertyName)),
                                    SyntaxFactory.IdentifierName(WellKnownMethodNames.CompareTo)))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName(RightEqualsArgumentName),
                                        SyntaxFactory.IdentifierName(UriOrignalStringPropertyName))))))));

            return methods;
        }

        private List<MethodDeclarationSyntax> GenerateObjectComparesExtensionMethod()
        {
            var methods = new List<MethodDeclarationSyntax>();
            /*
            public static int ObjectCompares(this object left, object right)
            {
                int compareResult = 0;

                if (left.TryReferenceCompares(right, out compareResult))
                {
                    return compareResult;
                }

                return Comparer<object>.Default.Compare(left, right);
            }
            */
            methods.Add(
                SyntaxFactory.MethodDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                    SyntaxFactory.Identifier(ObjectCompares))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(LeftEqualsArgumentName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    .WithType(
                        SyntaxFactory.IdentifierName(ObjectTypeName)),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(RightEqualsArgumentName))
                    .WithType(
                        SyntaxFactory.IdentifierName(ObjectTypeName)))
                .WithBody(
                    SyntaxFactory.Block(
                        DeclareCompareResultLocalVariable(CompareResultVariableName),
                        CallTryReferenceComparesMethod(),
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.GenericName(
                                                SyntaxFactory.Identifier(ComparerSuffix))
                                            .AddTypeArgumentListArguments(
                                                SyntaxFactory.IdentifierName(ObjectTypeName)),
                                            SyntaxFactory.IdentifierName("Default")),
                                    SyntaxFactory.IdentifierName(WellKnownMethodNames.Compare)))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.IdentifierName(LeftEqualsArgumentName)),
                                SyntaxFactory.Argument(
                                    SyntaxFactory.IdentifierName(RightEqualsArgumentName)))))));

            return methods;
        }

        #endregion

        private StatementSyntax DeclareCompareResultLocalVariable(string variableName)
        {
            /*
            int compareResult = 0;
            */
            return SyntaxFactory.LocalDeclarationStatement(
                SyntaxFactory.VariableDeclaration(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.IntKeyword)))
                .AddVariables(
                    SyntaxFactory.VariableDeclarator(
                        SyntaxFactory.Identifier(variableName))
                    .WithInitializer(
                        SyntaxFactory.EqualsValueClause(
                            SyntaxFactory.LiteralExpression(
                                SyntaxKind.NumericLiteralExpression,
                                SyntaxFactory.Literal(0))))));
        }

        private StatementSyntax AugumentNullCheck(string argumentName)
        {
            /*
            if (argument == null)
            {
                throw new ArgumentNullException(nameof(argument));
            }
            */
            return SyntaxFactory.IfStatement(
                SyntaxHelper.IsNull(argumentName),
                SyntaxFactory.Block(
                    SyntaxFactory.SingletonList<StatementSyntax>(
                        SyntaxFactory.ThrowStatement(
                            SyntaxFactory.ObjectCreationExpression(
                                SyntaxFactory.IdentifierName("ArgumentNullException"))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.InvocationExpression(
                                        SyntaxFactory.IdentifierName(
                                            SyntaxFactory.Identifier(
                                                SyntaxFactory.TriviaList(),
                                                SyntaxKind.NameOfKeyword,
                                                "nameof",
                                                "nameof",
                                                SyntaxFactory.TriviaList())))
                                    .AddArgumentListArguments(
                                            SyntaxFactory.Argument(
                                                SyntaxFactory.IdentifierName(argumentName)))))))));
        }

        private StatementSyntax CallTryReferenceComparesMethod()
        {
            /*
            // TryReferenceCompares is an autogenerated extension method
            // that will properly handle the case when 'left' is null.
            if (left.TryReferenceCompares(right, out compareResult))
            {
                return compareResult;
            }
            */
            return SyntaxFactory.IfStatement(
                SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(LeftEqualsArgumentName),
                        SyntaxFactory.IdentifierName(TryReferenceCompares)))
                .AddArgumentListArguments(
                    SyntaxFactory.Argument(
                        SyntaxFactory.IdentifierName(RightEqualsArgumentName)),
                    SyntaxFactory.Argument(
                        SyntaxFactory.IdentifierName(CompareResultVariableName))
                    .WithRefOrOutKeyword(
                        SyntaxFactory.Token(SyntaxKind.OutKeyword))),
                SyntaxFactory.Block(
                    SyntaxFactory.SingletonList<StatementSyntax>(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.IdentifierName(CompareResultVariableName)))))
                .WithIfKeyword(
                    SyntaxFactory.Token(
                        SyntaxFactory.TriviaList(new SyntaxTrivia[]
                        {
                            SyntaxFactory.CarriageReturnLineFeed,
                            SyntaxFactory.Comment("// TryReferenceCompares is an autogenerated extension method"),
                            SyntaxFactory.ElasticCarriageReturnLineFeed,
                            SyntaxFactory.Comment("// that will properly handle the case when 'left' is null."),
                            SyntaxFactory.ElasticCarriageReturnLineFeed,
                        }),
                        SyntaxKind.IfKeyword,
                        SyntaxFactory.TriviaList()));
        }

        private StatementSyntax CheckCompareResultAndReturn()
        {
            /*
            if (compareResult != 0)
            {
                return compareResult;
            }
            */
            return SyntaxFactory.IfStatement(
                SyntaxFactory.BinaryExpression(
                    SyntaxKind.NotEqualsExpression,
                    SyntaxFactory.IdentifierName(CompareResultVariableName),
                    SyntaxFactory.LiteralExpression(
                        SyntaxKind.NumericLiteralExpression,
                        SyntaxFactory.Literal(0))),
                SyntaxFactory.Block(
                    SyntaxFactory.SingletonList<StatementSyntax>(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.IdentifierName(CompareResultVariableName)))));
        }

        private ParameterSyntax CompareFunctionParameter(string functionName, string firstTypeParameter, string secondTypeParameter)
        {
            /*
            Func<T, T, int> compareFunction
            */
            return
                SyntaxFactory.Parameter(
                    SyntaxFactory.Identifier(functionName))
                .WithType(
                    SyntaxFactory.GenericName(
                        SyntaxFactory.Identifier("Func"))
                    .WithTypeArgumentList(
                        SyntaxFactory.TypeArgumentList(
                            SyntaxFactory.SeparatedList<TypeSyntax>(
                                new SyntaxNodeOrToken[]{
                                    SyntaxFactory.IdentifierName(firstTypeParameter),
                                    SyntaxFactory.Token(SyntaxKind.CommaToken),
                                    SyntaxFactory.IdentifierName(secondTypeParameter),
                                    SyntaxFactory.Token(SyntaxKind.CommaToken),
                                    SyntaxFactory.PredefinedType(
                                        SyntaxFactory.Token(SyntaxKind.IntKeyword))}))));
        }

        private ExpressionSyntax CompareFunctionLambdaExpression(string functionName, string firstParameterName, string secondParameterName)
        {
            /*
            (a, b) => functionName(a, b)
            */
            return
                SyntaxFactory.ParenthesizedLambdaExpression(
                    SyntaxFactory.ParameterList(
                        SyntaxFactory.SeparatedList<ParameterSyntax>(
                            new SyntaxNodeOrToken[]{
                                SyntaxFactory.Parameter(
                                    SyntaxFactory.Identifier(firstParameterName)),
                                SyntaxFactory.Token(SyntaxKind.CommaToken),
                                SyntaxFactory.Parameter(
                                    SyntaxFactory.Identifier(secondParameterName))})),
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.IdentifierName(functionName))
                    .AddArgumentListArguments(
                        SyntaxFactory.Argument(
                            SyntaxFactory.IdentifierName(firstParameterName)),
                        SyntaxFactory.Argument(
                            SyntaxFactory.IdentifierName(secondParameterName))));
        }

        private ExpressionSyntax CompareInvocationLambdaExpression(string compareFunction, string firstParameterName, string secondParameterName)
        {
            /*
            (a, b) => a.CompareTo(b)
            */
            return
                SyntaxFactory.ParenthesizedLambdaExpression(
                    SyntaxFactory.ParameterList(
                        SyntaxFactory.SeparatedList<ParameterSyntax>(
                            new SyntaxNodeOrToken[]{
                                SyntaxFactory.Parameter(
                                    SyntaxFactory.Identifier(firstParameterName)),
                                SyntaxFactory.Token(SyntaxKind.CommaToken),
                                SyntaxFactory.Parameter(
                                    SyntaxFactory.Identifier(secondParameterName))})),
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(firstParameterName),
                            SyntaxFactory.IdentifierName(compareFunction)))
                    .AddArgumentListArguments(
                        SyntaxFactory.Argument(
                            SyntaxFactory.IdentifierName(secondParameterName))));
        }
    }
}
