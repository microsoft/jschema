// Copyright (c) Microsoft Corporation.  All Rights Reserved.
// Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Json.Schema.ToDotNet
{
    internal class RewritingVisitorGenerator
    {
        private const string NodeParameterName = "node";
        private const string KeyParameterName = "key";
        private const string KeyVariableName = "key";
        private const string KeysVariableName = "keys";
        private const string KeysPropertyName = "Keys";
        private const string ValueVariableName = "value";
        private const string VisitMethodName = "Visit";
        private const string VisitActualMethodName = "VisitActual";
        private const string VisitNullCheckedMethodName = "VisitNullChecked";
        private const string VisitDictionaryEntryMethodName = "VisitDictionaryEntry";
        private const string TypeParameterName = "T";
        private const string CountPropertyName = "Count";
        private const string AddMethodName = "Add";
        private const string RemoveMethodName = "Remove";
        private const string ToArrayMethodName = "ToArray";

        private readonly TypeSyntax TypeParameterType = SyntaxFactory.ParseTypeName(TypeParameterName);
        private readonly TypeSyntax StringParameterType = SyntaxFactory.ParseTypeName("string");
        private readonly TypeSyntax NodeInterfaceType;

        private readonly Dictionary<string, PropertyInfoDictionary> _classInfoDictionary;
        private readonly string _copyrightNotice;
        private readonly string _namespaceName;
        private readonly string _className;
        private readonly string _schemaName;
        private readonly string _kindEnumName;
        private readonly List<string> _generatedClassNames;

        // The names of classes that occur in dictionary entries.
        private readonly IList<string> _dictionaryEntryClassNames;

        private readonly LocalVariableNameGenerator _localVariableNameGenerator;

        /// <summary>
        /// Initializes a new instance of the <see cref="RewritingVisitorGenerator"/> class.
        /// </summary>
        /// <param name="copyrightNotice">
        /// The copyright notice to display at the top of the file, or null if there is
        /// no copyright notice.
        /// </param>
        /// <param name="namespaceName">
        /// The name of the namespace into which the classes generated by this object
        /// are to be placed.
        /// </param>
        internal RewritingVisitorGenerator(
            Dictionary<string, PropertyInfoDictionary> classInfoDictionary,
            string copyrightNotice,
            string namespaceName,
            string className,
            string schemaName,
            string kindEnumName,
            string nodeInterfaceName,
            IEnumerable<string> generatedClassNames)
        {
            _classInfoDictionary = classInfoDictionary;
            _copyrightNotice = copyrightNotice;
            _namespaceName = namespaceName;
            _className = className;
            _schemaName = schemaName;
            _kindEnumName = kindEnumName;
            NodeInterfaceType = SyntaxFactory.ParseTypeName(nodeInterfaceName);
            _generatedClassNames = generatedClassNames.OrderBy(gn => gn).ToList();
            _dictionaryEntryClassNames = GetDictionaryEntryClassNames(classInfoDictionary);

            _localVariableNameGenerator = new LocalVariableNameGenerator();
        }

        /// <summary>
        /// Gets the list of schema-defined classes that appear as dictionary entries.
        /// </summary>
        /// <remarks>
        /// The property dictionary for a class contains one entry describing each property.
        /// For those properties that are dictionaries, the property dictionary also
        /// contains an entry that describes the dictionary _entry_. For example, suppose
        /// a class named Run contains a property named Graphs, defined as a dictionary
        /// from string to Graph. Then the property dictionary for the Run class contains
        /// one entry with the key "Graphs", which describes the property Run.Graphs.
        /// It contains another entry with the key "Graphs{}", which describes the
        /// entries in the Run.Graphs dictionary, and the PropertyInfo indexed by
        /// "Graphs{}" tells us that the dictionary entry is of the schema-defined
        /// type Graph. The string "{}" is called the "dictionary marker".
        ///
        /// Our goal is to locate dictionary-valued properties whose dictionary
        /// entries are of schema-defined types.
        /// </remarks>
        IList<string> GetDictionaryEntryClassNames(Dictionary<string, PropertyInfoDictionary> classInfoDictionary)
        {
            var dictionaryEntryClassNames = new HashSet<string>();

            // Loop over all properties of all classes defined in the schema.
            foreach (string className in classInfoDictionary.Keys)
            {
                PropertyInfoDictionary propertyInfoDictionary = classInfoDictionary[className];
                foreach (string key in propertyInfoDictionary.Keys)
                {
                    int dictionaryMarkerIndex = key.IndexOf(PropertyInfoDictionary.DictionaryMarker);
                    if (dictionaryMarkerIndex != -1)
                    {
                        // We've found a property info dictionary entry that describes
                        // an entry in a dictionary-valued property defined by the schema.
                        PropertyInfo dictionaryEntryInfo = propertyInfoDictionary[key];
                        {
                            if (dictionaryEntryInfo.IsOfSchemaDefinedType)
                            {
                                // The dictionary entries for this property are of schema-defined type!
                                // Remember this type so we can generate code to descend into the dictionary entries.
                                dictionaryEntryClassNames.Add(dictionaryEntryInfo.TypeName);
                            }
                        }
                    }
                }
            }

            return dictionaryEntryClassNames.OrderBy(name => name).ToList();
        }

        internal string GenerateRewritingVisitor()
        {
            ClassDeclarationSyntax visitorClassDeclaration =
                SyntaxFactory.ClassDeclaration(_className)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.AbstractKeyword))
                    .AddMembers(
                        GenerateVisitMethod(),
                        GenerateVisitActualMethod(),
                        GenerateVisitNullCheckedOneArgumentMethod(),
                        GenerateVisitNullCheckedTwoArgumentMethod(),
                        GenerateVisitDictionaryEntryMethod())
                    .AddMembers(
                        GenerateVisitTypedDictionaryEntryMethods())
                    .AddMembers(
                        GenerateVisitClassMethods());

            var usings = new HashSet<string> { "System", "System.Collections.Generic", "System.Linq" };

            string summaryComment = string.Format(
                CultureInfo.CurrentCulture,
                Resources.RewritingVisitorSummary,
                _schemaName);

            return visitorClassDeclaration.Format(
                _copyrightNotice,
                usings,
                _namespaceName,
                summaryComment);
        }

        private MemberDeclarationSyntax GenerateVisitMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(
                    SyntaxFactory.Token(SyntaxKind.ObjectKeyword)),
                VisitMethodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.VirtualKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(NodeInterfaceType))
                .AddBodyStatements(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.ThisExpression(),
                                SyntaxFactory.IdentifierName(VisitActualMethodName)))
                            .AddArgumentListArguments(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.IdentifierName(NodeParameterName)))))
                .WithLeadingTrivia(
                    SyntaxHelper.MakeDocComment(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            Resources.RewritingVisitorVisitMethodSummary,
                            _schemaName),
                        Resources.RewritingVisitorVisitMethodReturns,
                        new Dictionary<string, string>
                        {
                            [NodeParameterName] = Resources.RewritingVisitorVisitMethodNodeParameter
                        }));
        }

        private MemberDeclarationSyntax GenerateVisitActualMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)),
                VisitActualMethodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.VirtualKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(NodeInterfaceType))
                .AddBodyStatements(
                    SyntaxHelper.NullParameterCheck(NodeParameterName),
                    SyntaxFactory.SwitchStatement(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(NodeParameterName),
                            SyntaxFactory.IdentifierName(_kindEnumName)))
                            .AddSections(
                                GenerateVisitActualSwitchSections()))
                .WithLeadingTrivia(
                    SyntaxHelper.MakeDocComment(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            Resources.RewritingVisitorVisitActualMethodSummary,
                            _schemaName),
                        Resources.RewritingVisitorVisitActualMethodReturns,
                        new Dictionary<string, string>
                        {
                            [NodeParameterName] = Resources.RewritingVisitorVisitActualMethodNodeParameter
                        }));
        }

        private SwitchSectionSyntax[] GenerateVisitActualSwitchSections()
        {
            // There is one switch section for each generated class, plus one for the default.
            var switchSections = new SwitchSectionSyntax[_generatedClassNames.Count + 1];

            int index = 0;
            foreach (string generatedClassName in _generatedClassNames)
            {
                string methodName = MakeVisitClassMethodName(generatedClassName);

                switchSections[index++] = SyntaxFactory.SwitchSection(
                    SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                        SyntaxFactory.CaseSwitchLabel(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.IdentifierName(_kindEnumName),
                                SyntaxFactory.IdentifierName(generatedClassName)))),
                    SyntaxFactory.SingletonList<StatementSyntax>(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodName),
                                SyntaxFactory.ArgumentList(
                                    SyntaxFactory.SingletonSeparatedList(
                                        SyntaxFactory.Argument(
                                            SyntaxFactory.CastExpression(
                                                SyntaxFactory.ParseTypeName(generatedClassName),
                                                SyntaxFactory.IdentifierName(NodeParameterName)))))))));
            }

            switchSections[index] = SyntaxFactory.SwitchSection(
                SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                    SyntaxFactory.DefaultSwitchLabel()),
                SyntaxFactory.SingletonList<StatementSyntax>(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.IdentifierName(NodeParameterName))));

            return switchSections;
        }

        private MethodDeclarationSyntax GenerateVisitNullCheckedOneArgumentMethod()
        {
            const string EmptyKeyVariableName = "emptyKey";

            return SyntaxFactory.MethodDeclaration(
                TypeParameterType,
                VisitNullCheckedMethodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(TypeParameterName))
                .AddConstraintClauses(
                    SyntaxFactory.TypeParameterConstraintClause(
                        SyntaxFactory.IdentifierName(TypeParameterName),
                        SyntaxFactory.SeparatedList(
                            new TypeParameterConstraintSyntax[]
                            {
                                SyntaxFactory.ClassOrStructConstraint(SyntaxKind.ClassConstraint),
                                SyntaxFactory.TypeConstraint(NodeInterfaceType)
                            })))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(TypeParameterType))
                .AddBodyStatements(
                    // string emptyKey = null;
                    SyntaxFactory.LocalDeclarationStatement(
                        SyntaxFactory.VariableDeclaration(
                            StringParameterType,
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.VariableDeclarator(
                                    SyntaxFactory.Identifier(EmptyKeyVariableName),
                                    default(BracketedArgumentListSyntax),
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)))))),
                    // return VisitNullChecked<T>(node, ref emptyKey)
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.GenericName(
                                SyntaxFactory.Identifier(VisitNullCheckedMethodName),
                                SyntaxFactory.TypeArgumentList(
                                    SyntaxFactory.SingletonSeparatedList(TypeParameterType))),
                            SyntaxHelper.ArgumentList(
                                SyntaxFactory.IdentifierName(NodeParameterName),
                                SyntaxFactory.RefExpression(
                                    SyntaxFactory.IdentifierName(EmptyKeyVariableName))))));
        }

        private MethodDeclarationSyntax GenerateVisitNullCheckedTwoArgumentMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                TypeParameterType,
                VisitNullCheckedMethodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword))
                .AddTypeParameterListParameters(
                    SyntaxFactory.TypeParameter(TypeParameterName))
                .AddConstraintClauses(
                    SyntaxFactory.TypeParameterConstraintClause(
                        SyntaxFactory.IdentifierName(TypeParameterName),
                        SyntaxFactory.SeparatedList(
                            new TypeParameterConstraintSyntax[]
                            {
                                SyntaxFactory.ClassOrStructConstraint(SyntaxKind.ClassConstraint),
                                SyntaxFactory.TypeConstraint(NodeInterfaceType)
                            })))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(TypeParameterType),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(KeyParameterName))
                        .WithType(StringParameterType)
                        .WithModifiers(SyntaxTokenList.Create(SyntaxFactory.Token(SyntaxKind.RefKeyword))))
                .AddBodyStatements(
                    SyntaxFactory.IfStatement(
                        SyntaxHelper.IsNull(NodeParameterName),
                        SyntaxFactory.Block(
                            SyntaxFactory.ReturnStatement(
                                SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)))),
                    SyntaxFactory.IfStatement(
                        SyntaxHelper.IsNull(KeyParameterName),
                        SyntaxFactory.Block(
                            SyntaxFactory.ReturnStatement(
                                SyntaxFactory.CastExpression(
                                    TypeParameterType,
                                    SyntaxFactory.InvocationExpression(
                                        SyntaxFactory.IdentifierName(VisitMethodName),
                                        SyntaxFactory.ArgumentList(
                                            SyntaxFactory.SingletonSeparatedList(
                                                SyntaxFactory.Argument(
                                                    SyntaxFactory.IdentifierName(NodeParameterName))))))))),
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.CastExpression(
                            TypeParameterType,
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(VisitDictionaryEntryMethodName),
                                SyntaxHelper.ArgumentList(
                                    SyntaxFactory.IdentifierName(NodeParameterName),
                                    SyntaxFactory.RefExpression(
                                        SyntaxFactory.IdentifierName(KeyParameterName)))))));
        }

        private MethodDeclarationSyntax GenerateVisitDictionaryEntryMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                NodeInterfaceType,
                VisitDictionaryEntryMethodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(NodeInterfaceType),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(KeyParameterName))
                        .WithType(StringParameterType)
                        .WithModifiers(SyntaxTokenList.Create(SyntaxFactory.Token(SyntaxKind.RefKeyword))))
                .AddBodyStatements(
                    SyntaxHelper.NullParameterCheck(NodeParameterName),
                    SyntaxHelper.NullParameterCheck(KeyParameterName),
                    SyntaxFactory.SwitchStatement(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(NodeParameterName),
                            SyntaxFactory.IdentifierName(_kindEnumName)))
                        .AddSections(GenerateVisitDictionaryEntrySwitchSections()));
        }

        private SwitchSectionSyntax[] GenerateVisitDictionaryEntrySwitchSections()
        {
            // There is one switch section for each class that can occur in a dictionary, plus one for the default.
            var switchSections = new SwitchSectionSyntax[_dictionaryEntryClassNames.Count + 1];

            int index = 0;
            foreach (string className in _dictionaryEntryClassNames)
            {
                string methodName = MakeVisitDictionaryEntryMethodName(className);
                switchSections[index++] = SyntaxFactory.SwitchSection(
                    SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                        SyntaxFactory.CaseSwitchLabel(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.IdentifierName(_kindEnumName),
                                SyntaxFactory.IdentifierName(className)))),
                    SyntaxFactory.SingletonList<StatementSyntax>(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodName),
                                SyntaxHelper.ArgumentList(
                                    SyntaxFactory.CastExpression(
                                        SyntaxFactory.ParseTypeName(className),
                                        SyntaxFactory.IdentifierName(NodeParameterName)),
                                    SyntaxFactory.RefExpression(
                                        SyntaxFactory.IdentifierName(KeyParameterName)))))));
            }

            switchSections[index] = SyntaxFactory.SwitchSection(
                SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                    SyntaxFactory.DefaultSwitchLabel()),
                SyntaxFactory.SingletonList<StatementSyntax>(
                    SyntaxFactory.ThrowStatement(
                        SyntaxHelper.NewInvalidOperationException())));

            return switchSections;
        }

        private string MakeVisitDictionaryEntryMethodName(string className)
        {
            return "Visit" + className + "DictionaryEntry";
        }
        private MemberDeclarationSyntax[] GenerateVisitTypedDictionaryEntryMethods()
        {
            // There is one method for each class that can occur in a dictionary.
            var methodDeclarations = new MemberDeclarationSyntax[_dictionaryEntryClassNames.Count];

            int index = 0;
            foreach (string className in _dictionaryEntryClassNames)
            {
                methodDeclarations[index++] = GenerateVisitTypedDictionaryEntryMethods(className);
            }

            return methodDeclarations;
        }

        private MemberDeclarationSyntax GenerateVisitTypedDictionaryEntryMethods(string className)
        {
            string methodName = MakeVisitDictionaryEntryMethodName(className);
            TypeSyntax generatedClassType = SyntaxFactory.ParseTypeName(className);

            return SyntaxFactory.MethodDeclaration(generatedClassType, methodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.VirtualKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(NodeParameterName))
                        .WithType(generatedClassType),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(KeyParameterName))
                        .WithType(StringParameterType)
                        .WithModifiers(SyntaxTokenList.Create(SyntaxFactory.Token(SyntaxKind.RefKeyword))))
                .AddBodyStatements(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.CastExpression(
                            generatedClassType,
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(VisitMethodName),
                                SyntaxHelper.ArgumentList(
                                    SyntaxFactory.IdentifierName(NodeParameterName))))));
        }

        private MemberDeclarationSyntax[] GenerateVisitClassMethods()
        {
            // There is one VisitXxx method for each generated class.
            var visitClassMethods = new MemberDeclarationSyntax[_generatedClassNames.Count];

            int index = 0;
            foreach (string generatedClassName in _generatedClassNames)
            {
                visitClassMethods[index++] = GenerateVisitClassMethod(generatedClassName);
            }

            return visitClassMethods;
        }

        /// <summary>
        /// Generate the visitor method for one of the classes defined by the schema.
        /// </summary>
        /// <param name="className">
        /// The name of the class for which a visitor method is to be generated.
        /// </param>
        /// <returns>
        /// A method declaration for the vistor method.
        /// </returns>
        /// <example>
        /// <code>
        /// public virtual VisitLocation(Location node)
        /// {
        ///     if (node != null)
        ///     {
        ///         // GenerateVisitClassBodyStatements()
        ///     }
        ///
        ///     return node;
        /// }
        /// </code>
        /// </example>
        private MethodDeclarationSyntax GenerateVisitClassMethod(string className)
        {
            string methodName = MakeVisitClassMethodName(className);
            TypeSyntax generatedClassType = SyntaxFactory.ParseTypeName(className);

            return SyntaxFactory.MethodDeclaration(generatedClassType, methodName)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.VirtualKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(NodeParameterName))
                    .WithType(generatedClassType))
                .AddBodyStatements(
                    SyntaxFactory.IfStatement(
                        SyntaxHelper.IsNotNull(NodeParameterName),
                        SyntaxFactory.Block(
                            GeneratePropertyVisits(className))),
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.IdentifierName(NodeParameterName)));
        }

        /// <summary>
        /// Generate the code necessary to visit each property.
        /// </summary>
        /// <param name="className">
        /// The name of the class for which the visitor method is being generated.
        /// </param>
        /// <returns>
        /// The statements necessary to visit each property in the class.
        /// </returns>
        /// <remarks>
        /// It is only necessary to visit those properties which are themselves of a
        /// schema-defined type. Scalar properties can be visited directly. For properties
        /// of array type, each element must be visited.
        /// </remarks>
        /// <example>
        /// Visiting a class with one scalar-valued property and one array-valued property:
        /// <code>
        /// node.MessageDescriptor = VisitNullChecked(node.MessageDescriptor);
        /// 
        /// if (node.Locations != null)
        /// {
        ///     // GenerateArrayVisit()
        /// }
        /// </code>
        /// </example>
        private StatementSyntax[] GeneratePropertyVisits(string className)
        {
            var statements = new List<StatementSyntax>();

            PropertyInfoDictionary propertyInfoDictionary = _classInfoDictionary[className];
            foreach (KeyValuePair<string, PropertyInfo> entry in propertyInfoDictionary.OrderBy(kvp => kvp.Value.DeclarationOrder))
            {
                string propertyNameWithRank = entry.Key;
                PropertyInfo propertyInfo = entry.Value;

                // We only need to visit properties whose type is one of the classes
                // defined by the schema.
                if (!propertyInfo.IsOfSchemaDefinedType)
                {
                    continue;
                }

                string propertyName = propertyNameWithRank.BasePropertyName(out int arrayRank, out bool isDictionary);

                TypeSyntax collectionType = propertyInfoDictionary.GetConcreteListType(propertyName);
                TypeSyntax elementType = propertyInfoDictionary[propertyNameWithRank].Type;

                ExpressionSyntax propertyAccessExpression =
                    SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(NodeParameterName),
                            SyntaxFactory.IdentifierName(propertyName));

                if (arrayRank == 0 && !isDictionary)
                {
                    // This is a simple scalar assignment.
                    statements.Add(GenerateScalarVisit(propertyAccessExpression));
                }
                else
                {
                    _localVariableNameGenerator.Reset();

                    StatementSyntax[] nullTestedStatements = null;
                    if (isDictionary)
                    {
                        nullTestedStatements = GenerateDictionaryVisit(arrayRank, propertyName);
                    }
                    else
                    {
                        nullTestedStatements = GenerateArrayVisit(
                            arrayRank,
                            nestingLevel: 0,
                            arrayValuedExpression: propertyAccessExpression);
                    }

                    statements.Add(
                        SyntaxFactory.IfStatement(
                            SyntaxHelper.IsNotNull(
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    SyntaxFactory.IdentifierName(NodeParameterName),
                                    SyntaxFactory.IdentifierName(propertyName))),
                            SyntaxFactory.Block(nullTestedStatements)));
                }
            }

            return statements.ToArray();
        }

        private StatementSyntax GenerateScalarVisit(
            ExpressionSyntax target,
            ExpressionSyntax source = null)
        {
            if (source == null)
            {
                source = target;
            }

            return
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        target,
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName(VisitNullCheckedMethodName),
                            SyntaxHelper.ArgumentList(source))));
        }

        private StatementSyntax[] GenerateDictionaryVisit(int arrayRank, string propertyName)
        {
            ExpressionSyntax dictionaryValue =
                SyntaxFactory.ElementAccessExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(NodeParameterName),
                        SyntaxFactory.IdentifierName(propertyName)),
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.Argument(
                                SyntaxFactory.IdentifierName(KeyVariableName)))));

            // The code to visit an individual dictionary element depends on whether the
            // elements are scalar values or arrays.
            StatementSyntax[] dictionaryElementVisitStatements;

            if (arrayRank == 0)
            {
                dictionaryElementVisitStatements = GenerateDictionaryElementVisit(propertyName);
            }
            else
            {
                ExpressionSyntax arrayValuedExpression =
                    SyntaxFactory.ElementAccessExpression(
                        SyntaxFactory.MemberAccessExpression(
                                   SyntaxKind.SimpleMemberAccessExpression,
                                   SyntaxFactory.IdentifierName(NodeParameterName),
                                   SyntaxFactory.IdentifierName(propertyName)),
                        SyntaxFactory.BracketedArgumentList(
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.IdentifierName(KeyVariableName)))));

                dictionaryElementVisitStatements = GenerateArrayVisit(
                    arrayRank,
                    nestingLevel: 0,
                    arrayValuedExpression: arrayValuedExpression);
            }

            return new StatementSyntax[]
            {
                // var keys = node.PropertyName.Keys.ToArray();
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxHelper.Var(),
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.VariableDeclarator(
                                SyntaxFactory.Identifier(KeysVariableName),
                                default(BracketedArgumentListSyntax),
                                SyntaxFactory.EqualsValueClause(
                                    SyntaxFactory.InvocationExpression(
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    SyntaxFactory.IdentifierName(NodeParameterName),
                                                    SyntaxFactory.IdentifierName(propertyName)),
                                                SyntaxFactory.IdentifierName(KeysPropertyName)),
                                            SyntaxFactory.IdentifierName(ToArrayMethodName)),
                                        SyntaxHelper.ArgumentList())))))),

                // foreach (var key in keys)
                SyntaxFactory.ForEachStatement(
                    SyntaxHelper.Var(),
                    KeyVariableName,
                    SyntaxFactory.IdentifierName(KeysVariableName),
                    SyntaxFactory.Block(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxHelper.Var(),
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.VariableDeclarator(
                                        SyntaxFactory.Identifier(ValueVariableName),
                                        default(BracketedArgumentListSyntax),
                                        SyntaxFactory.EqualsValueClause(dictionaryValue))))),
                        SyntaxFactory.IfStatement(
                            SyntaxHelper.IsNotNull(ValueVariableName),
                            SyntaxFactory.Block(dictionaryElementVisitStatements))))
            };
        }

        private StatementSyntax[] GenerateDictionaryElementVisit(string propertyName)
        {
            const string NewKeyVariableName = "newKey";

            return new StatementSyntax[]
            {
                // string newKey = key;
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        StringParameterType,
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.VariableDeclarator(
                                SyntaxFactory.Identifier(NewKeyVariableName),
                                default(BracketedArgumentListSyntax),
                                SyntaxFactory.EqualsValueClause(
                                    SyntaxFactory.IdentifierName(KeyVariableName)))))),
                // node.Property.Remove(key);
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.IdentifierName(NodeParameterName),
                                SyntaxFactory.IdentifierName(propertyName)),
                            SyntaxFactory.IdentifierName(RemoveMethodName)),
                        SyntaxHelper.ArgumentList(
                            SyntaxFactory.IdentifierName(KeyVariableName)))),
                // value = VisitNullChecked(value, ref newKey);
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(ValueVariableName),
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName(VisitNullCheckedMethodName),
                            SyntaxHelper.ArgumentList(
                                SyntaxFactory.IdentifierName(ValueVariableName),
                                SyntaxFactory.RefExpression(
                                    SyntaxFactory.IdentifierName(NewKeyVariableName)))))),
                // if (newKey != null)
                SyntaxFactory.IfStatement(
                    SyntaxHelper.IsNotNull(NewKeyVariableName),
                    SyntaxFactory.Block(
                        SyntaxFactory.ExpressionStatement(
                            // node.Property[newKey] = VisitNullChecked(value);
                            SyntaxFactory.AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                SyntaxFactory.ElementAccessExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName(NodeParameterName),
                                        SyntaxFactory.IdentifierName(propertyName)),
                                    SyntaxHelper.BracketedArgumentList(
                                        SyntaxFactory.IdentifierName(NewKeyVariableName))),
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.IdentifierName(VisitNullCheckedMethodName),
                                    SyntaxHelper.ArgumentList(
                                        SyntaxFactory.IdentifierName(ValueVariableName)))))))
            };
        }

        private StatementSyntax[] GenerateArrayVisit(
            int arrayRank,
            int nestingLevel,
            ExpressionSyntax arrayValuedExpression)
        {
            ExpressionSyntax loopLimitExpression;
            if (nestingLevel == 0)
            {
                // node.Locations.Count
                loopLimitExpression = SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    arrayValuedExpression,
                    SyntaxFactory.IdentifierName(CountPropertyName));
            }
            else
            {
                // value_0.Count
                loopLimitExpression = SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.IdentifierName(
                        LocalVariableNameGenerator.GetCollectionElementVariableName(nestingLevel - 1)),
                    SyntaxFactory.IdentifierName(CountPropertyName));
            }

            var statements = new List<StatementSyntax>();
            if (nestingLevel < arrayRank)
            {
                // We're not yet at the innermost level, so we need another for loop.
                string loopVariableName = LocalVariableNameGenerator.GetLoopIndexVariableName(nestingLevel);
                string outerLoopVariableName = LocalVariableNameGenerator.GetLoopIndexVariableName(nestingLevel - 1);
                string arrayElementVariableName = LocalVariableNameGenerator.GetCollectionElementVariableName(nestingLevel - 1);

                // For every level except the outermost, we need to get an array element and test whether
                // it's null.
                if (nestingLevel > 0)
                {

                    // var value_0 = node.Locations[index_0];
                    statements.Add(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxHelper.Var(),
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.VariableDeclarator(
                                        SyntaxFactory.Identifier(arrayElementVariableName),
                                        default(BracketedArgumentListSyntax),
                                        SyntaxFactory.EqualsValueClause(
                                            SyntaxFactory.ElementAccessExpression(
                                                arrayValuedExpression,
                                                SyntaxFactory.BracketedArgumentList(
                                                    SyntaxFactory.SingletonSeparatedList(
                                                        SyntaxFactory.Argument(
                                                            SyntaxFactory.IdentifierName(outerLoopVariableName)))))))))));
                }

                // for
                ForStatementSyntax forStatement = SyntaxFactory.ForStatement(
                        // (index_0 = 0;
                        SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.VariableDeclarator(loopVariableName)
                                    .WithInitializer(
                                        SyntaxFactory.EqualsValueClause(SyntaxFactory.LiteralExpression(
                                            SyntaxKind.NumericLiteralExpression,
                                            SyntaxFactory.Literal(0)))))),
                        default(SeparatedSyntaxList<ExpressionSyntax>),
                        // index_0 < value_0.Count;
                        SyntaxFactory.BinaryExpression(
                            SyntaxKind.LessThanExpression,
                            SyntaxFactory.IdentifierName(loopVariableName),
                            loopLimitExpression),
                        // ++index_0)
                        SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                            SyntaxFactory.PrefixUnaryExpression(
                                SyntaxKind.PreIncrementExpression,
                                SyntaxFactory.IdentifierName(loopVariableName))),
                        // { ... }
                        SyntaxFactory.Block(
                            GenerateArrayVisit(arrayRank, nestingLevel + 1, arrayValuedExpression)));

                if (nestingLevel > 0)
                {
                    statements.Add(
                        SyntaxFactory.IfStatement(
                            SyntaxHelper.IsNotNull(arrayElementVariableName),
                            SyntaxFactory.Block(
                                forStatement)));
                }
                else
                {
                    statements.Add(forStatement);
                }
            }
            else
            {
                string loopVariableName = LocalVariableNameGenerator.GetLoopIndexVariableName(nestingLevel - 1);

                // We're in the body of the innermost loop over array elements. This is
                // where we do the assignment. For arrays of rank 1, the assignment is
                // to an element of the property itself. For arrays of rank > 1, the
                // assignment is to an array element of a temporary variable representing
                // one of the elements of the property.
                ElementAccessExpressionSyntax elementAccessExpression;
                if (arrayRank == 1)
                {
                    // node.Location[index_0]
                    elementAccessExpression =
                        SyntaxFactory.ElementAccessExpression(
                            arrayValuedExpression,
                            SyntaxFactory.BracketedArgumentList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory.IdentifierName(loopVariableName)))));
                }
                else
                {
                    string arrayElementVariableName = LocalVariableNameGenerator.GetCollectionElementVariableName(nestingLevel - 2);

                    // value_0[index_1]
                    elementAccessExpression =
                        SyntaxFactory.ElementAccessExpression(
                            SyntaxFactory.IdentifierName(arrayElementVariableName),
                            SyntaxFactory.BracketedArgumentList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory.IdentifierName(loopVariableName)))));
                }

                statements.Add(
                    SyntaxFactory.ExpressionStatement(
                        SyntaxFactory.AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            elementAccessExpression,
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(VisitNullCheckedMethodName),
                                SyntaxHelper.ArgumentList(elementAccessExpression)))));
            }

            return statements.ToArray();
        }

        private string MakeVisitClassMethodName(string className)
        {
            return VisitMethodName + className;
        }
    }
}
